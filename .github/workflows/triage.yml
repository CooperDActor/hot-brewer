name: Triage

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - closed
      - labeled
      - unlabeled
  schedule:
    - cron: '0 */3 * * *' # every 3 hours

jobs:
  review:
    runs-on: ubuntu-latest
    if: startsWith(github.repository, 'Homebrew/')
    steps:
      - name: Re-run this workflow
        if: github.event_name == 'schedule' || github.event.action == 'closed'
        uses: reitermarkus/rerun-workflow@cf91bee6964dfde64eccbf5600c3ea206af11359
        with:
          token: ${{ secrets.HOMEBREW_GITHUB_API_TOKEN }}
          continuous-label: waiting for feedback
          trigger-labels: critical
          workflow: triage.yml
      - name: Review pull request
        if: >
          (github.event_name == 'pull_request' || github.event_name == 'pull_request_target') &&
            (github.event.action != 'closed' && !(github.event.action == 'unlabeled' && github.event.label.name == 'waiting for feedback'))
        uses: actions/github-script@v3
        with:
          github-token: ${{ secrets.HOMEBREW_GITHUB_API_TOKEN }}
          script: |
            core.info(JSON.stringify(context, null, 2))

            async function approvePullRequest(pullRequestNumber, message) {
              await github.pulls.createReview({
                ...context.repo,
                pull_number: pullRequestNumber,
                event: 'APPROVE',
                body: message,
              })
            }

            async function createOrUpdateComment(pullRequestNumber, id, message) {
              const { data: comments } = await github.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pullRequestNumber,
              })

              core.info(JSON.stringify(comments, null, 2))

              const regex = new RegExp(`<!--\\s*#${id}\\s*-->`)
              const beginComment = comments.filter(comment => comment.body.match(regex))[0]

              const body = `<!-- #${id} -->\n\n${message}`
              if (beginComment) {
                await github.issues.updateComment({
                  ...context.repo,
                  issue_number: pullRequestNumber,
                  comment_id: beginComment.id,
                  body,
                })
              } else {
                await github.issues.createComment({
                  ...context.repo,
                  issue_number: pullRequestNumber,
                  body,
                })
              }

              core.info(`Begin Comment:\n${beginComment.body}`)
            }

            async function reviewPullRequest(pullRequestNumber) {
              const { data: pullRequest } = await github.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pullRequestNumber,
              })

              core.info(JSON.stringify(pullRequest, null, 2))

              if (pullRequest.author_association != 'MEMBER') {
                core.warning('Pull request author is not a member.')
                return
              }

              const reviewLabel = 'waiting for feedback'
              const criticalLabel = 'critical'

              const labels = pullRequest.labels.map(label => label.name)
              const hasReviewLabel = labels.includes(reviewLabel)
              const hasCriticalLabel = labels.includes(criticalLabel)

              if (hasCriticalLabel) {
                if (hasReviewLabel) {
                  await github.issues.removeLabel({
                    ...context.repo,
                    issue_number: pullRequestNumber,
                    name: reviewLabel,
                  })

                  const message = `Review period cancelled due to \`${criticalLabel}\` label.`
                  core.info(message)

                  await approvePullRequest(pullRequestNumber, message)
                } else {
                  const message = `Review period skipped due to \`${criticalLabel}\` label.`
                  core.info(message)

                  await approvePullRequest(pullRequestNumber, message)
                }

                return
              }

              const reviewStartDate = new Date(pullRequest.created_at)
              const reviewEndDate = new Date(reviewStartDate)
              switch (reviewStartDate.getDay()) {
                // Skip from Friday to Monday and from Saturday to Tuesday.
                case 5:
                case 6:
                  reviewEndDate.setDate(reviewStartDate.getDate() + 3)
                  break
                // Skip from Sunday to Tuesday.
                case 0:
                  reviewEndDate.setDate(reviewStartDate.getDate() + 2)
                  break
                default:
                  reviewEndDate.setDate(reviewStartDate.getDate() + 1)
                  break
              }

              const currentDate = new Date()
              const reviewEnded = currentDate > reviewEndDate

              function formatDate(date) {
                return date.toISOString().replace(/\.\d+Z$/, ' UTC').replace('T', ' at ')
              }

              if (reviewEnded) {
                const message = 'Review period ended.'
                core.warning(message)

                if (hasReviewLabel) {
                  await github.issues.removeLabel({
                    ...context.repo,
                    issue_number: pullRequestNumber,
                    name: reviewLabel,
                  })

                  await approvePullRequest(pullRequestNumber, message)
                }
              } else {
                const message = `Review period will end on ${formatDate(reviewEndDate)}.`
                core.warning(message)

                await createOrUpdateComment(pullRequestNumber, 'review-period-begin', message)
                await github.issues.addLabels({
                  ...context.repo,
                  issue_number: pullRequestNumber,
                  labels: [reviewLabel],
                })

                core.setFailed('Review period has not ended yet.')
              }
            }

            await reviewPullRequest(context.issue.number)
